# this file is: /etc/musync.conf
# I can also be in: ~/.musync
#
# first off:
# MUSYNC WILL NOT FIX BROKEN META DATA
#
# therefore if you (theoretically of course) download a bunch of 'scene'
# music and just go ahead and add them using musync - chanses are you will
# get dissapointed.  Yes, even 'scene' music sucks at tagging. Use a tagger
# like Musicbrainz Picard to properly tag your music _before_ trying to add it.
#

[general]

# This section will always be used.  All the other sections are optional
# and will only be used if specified with the key 'default-config' or if
# specifically used when running musync (-c [section],..)
# 
# When used with musync the sections are read from left to right, you will
# get an error when using cyclic options (infinite recursion).
# 
# The general rule of thumb is that each key here has it's counteroption in
# the commandline interface.  This means that writing 'pretend: true' would
# be the same as using 'musync --pretend'.  Commandline options _always_
# has precedence.

os: import os
sh: import shutil
m:  import musync.custom

# if you look in the [main] section, you see a root and a new default-config specified.
# specifies 'default-config'

# pretend tells musync to not actually 'do' anything but just explain what it would do.
pretend: lambda: False

# Log-files...
#log: lambda: "/tmp/musync.log"

# Force is used in different contexts, it is greatly discouraged to set it other than 'false'
force: lambda: False
# These are the different commands that are run when certain actions are performed.
rm:lambda p: os.unlink(p.path)

# Specifies how to create the hash, the output is splitted by whitespace and the first split is used.
hash: lambda target: m.md5sum(target)

# Add command musync uses.
add: lambda src, dst: sh.move(src, dst)

# Weither to check hash or not.
checkhash: lambda meta: True

# Formatting of music files
# Track number is not filtered.
# the different fields are artist, album and title.
#filter-with: /usr/bin/sed -r -f /etc/musync.%(field)s.sed
#filter: lambda value: m.ue(m.filter(value, "/bin/sed", "-r", "-f", "/etc/musync.sed"))
cfilter: lambda value: m.ue(m.lexer("/etc/musync.rules", value).lower())
cdir:    lambda meta: "{0}/{1:0>4d}-{2}".format(cfilter(meta.artist) or "no-artist", meta.year or 0, cfilter(meta.album) or "no-album")
cfile:   lambda meta: "{0:0>2d}-{1}.{2}".format(meta.track or 0, cfilter(meta.title) or "no-title", meta.ext)

# the path in which to 'add' files
targetpath: lambda p: os.path.join(cdir(p.meta), cfile(p.meta))

# Define what noticelevels are supressed.
# available are:
#     notice - general notices, not important but informative.
#     warning - musync explains why it couldn't do a certain action, this should be visible.
#     error - this is when musync encounters a fatal exception and has to stop short in execution.
suppressed: lambda: ["notice", "warning"]
silent:     lambda: False

# - transcoding -
# transcoding has been formed to be as simple and customizable as possible.
# the key that a certain transcoding will look for is *ext*-to-*ext*.
# the command that is used must of course exist on the system.
# the available variables are:
#   %(source)s - the source file (the one to be transcoded).
#   %(dest)s - the destination file (the result of the transcoding).
# uncomment these and modify to your needs.
#wav-to-ogg: oggenc %(source)s -o %(dest)s -q 8

# transcode formats
# this key means to transform all wav and flac files to ogg.
# this is useful when putting your music into (for example) a digital audio player.
# This key means; transcode wav and flac into ogg.
# Note: the 'wav-to-ogg' key is missing.
#transcode: wav,flac=ogg

root:   lambda: "/mnt/hdb1/music"
lockdb: lambda: os.path.join(root(), ".lock")

configurations: lambda: ["copy"]

[link]
#
# i had a friend that used to symlink his entire music library from is "import" catalogue without having to copy or move
# the original files. This is very useful when doing something like that.
# 
# use by setting option '-c link' with musync.
#
add:        lambda src, dst: os.symlink(src, dst)
checkhash:  lambda meta: False

[copy]
#
# this is generally the most used option.
# why you don't want to 'mv' the files: 
#

# copy is the default action.
add:  lambda src, dst: sh.copy(src, dst)

[move]
# use move at your own risk, hashing will currently not work.
add:lambda src, dst: sh.move(src, dst)
rm: lambda p: os.unlink(p.path)

[dap]
#
# I use this to sync agains my digital audio player.
#

flac_to_ogg:    lambda src, dst: m.system("/usr/bin/oggenc", src, "-o", dst, "-q", "8")
transcode:      lambda: [('flac', 'ogg', flac_to_ogg)]
root:           lambda: "/home/udoprog/music"
silent:         lambda: False

[search-year]
add:        lambda src, dst: os.symlink(src, dst)
checkhash:  lambda: False

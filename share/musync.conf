[import]
# the 'import' section is run prior to any existing lambda expression.
# therefore all that is imported here, will be available in any successive action.
# this is also a nice place to add your own library hacks!
os: os
sh: shutil
m:  musync.custom
tmp: tempfile

[general]

### Static Variables ###
# root directory (used in 'targetpath').
root:"/mnt/hdb1/music"

# Which printer levels that should be suppressed on 'silent'
suppressed: ["notice", "warning"]

# Which configurations to overlay.
configurations: ["copy"]

### Behaviour Modifiers ###
pretend:    False
force:      False
silent:     False
checkhash:  True
debug:      False

### Required Functions ###
## Therse are and must be lambda expression (e.g. of python type: types.FunctionType)
## Which could be a normal function (def) aswell imported elsewhere.
# How musync removes files
rm:   lambda p: os.unlink(p.path)

# How musync add files (note; will be overwritten by 'configurations')
add:  lambda src, dst: m.safecopy(src.path, dst.path, hasher=hash)

# How musync performs checksums on a file, must return a file-unique string.
hash: lambda target: m.md5sum(target)

# targetpath helper functions
cfilter: lambda value: m.ue(m.lexer("/etc/musync.rules", value).lower())
cdir:    lambda meta: "{0}/{1:0>4d}-{2}".format(cfilter(meta.artist) or "no-artist", meta.year or 0, cfilter(meta.album) or "no-album")
cfile:   lambda meta: "{0:0>2d}-{1}.{2}".format(meta.track or 0, cfilter(meta.title) or "no-title", meta.ext)

targetpath: lambda p: os.path.join(cdir(p.meta), cfile(p.meta))

# Where to find the lock-database.
# this is just a flat-file database where each line indicates a file or directory that is locked.
# Musync will not perform any action against a locked file or directory other than 'unlock'
lockdb: lambda: os.path.join(root, ".lock")

[copy]
# Safe copy operation, this will be retried if the checksums do not match.
# add: lambda src, dst: sh.copy(src, dst)

[move]
# Destructive move operation, if this fails, there will be no turning back.
add: lambda src, dst: sh.move(src.path, dst.path)

[test]
root:"/home/udoprog/music"

[dap]
### Static Variables ###

# New root for Digital Audio Players.
root:"/home/udoprog/music"

pre-add: lambda src, dst: dst.update(ext="ogg")

default: lambda s, d: m.safecopy(s.path, d.path, hasher=md5sum)
add: lambda s, d: m.case(s.ext, (('flac', 'wav'), ogg_encode), mp3=mp3_to_ogg, _=default)(s, d)
# Transcoding helper functions.

x_to_ogg_t:lambda s,d: ogg_encode(s,d)

# transcoding from ogg to mp3 requires a temporary file, use in_tmp to pass one as the forst argument to mpt_to_ogg.
# in_tmp will make sure that the temporary file is removed no matter what.
mp3_to_ogg:lambda ss,dd: m.in_tmp(lambda t,s,d: mp3_decode(s.path,t) and ogg_encode(t,d.path),ss,dd)

# EVEN MORE helpers.
mp3_decode:lambda s,d: m.system("mpg321",s,"-w",d)
ogg_encode:lambda s,d: m.system("/usr/bin/oggenc",s,"-o",d,"-q","8")
